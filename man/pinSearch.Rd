% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pinSearch.R
\name{pinSearch}
\alias{pinSearch}
\title{Search for noninvariant parameters across groups.}
\usage{
pinSearch(
  config_mod,
  data = NULL,
  group = NULL,
  ordered = NULL,
  parameterization = "theta",
  ...,
  type = c("loadings", "intercepts", "thresholds", "residuals", "residual.covariances"),
  test = c("mod", "score"),
  sig_level = 0.05,
  control_fdr = FALSE,
  effect_size = FALSE,
  progress = FALSE
)
}
\arguments{
\item{config_mod}{Syntax of a configural invariance model to be passed to
\code{\link[lavaan:cfa]{lavaan::cfa()}}.}

\item{data}{A data frame to be passed to \code{\link[lavaan:cfa]{lavaan::cfa()}}.}

\item{group}{Character indicating the variable name in \code{data} that
defines the grouping variable in multiple-group CFA.}

\item{ordered}{Character vector indicating names of variables to be treated
as binary or ordinal. IF \code{NULL}, all items are treated as continuous.}

\item{parameterization}{Character, either "theta" or "delta". "theta" should
be used for invariance testing, and is the only method tested.}

\item{...}{Additonal arguments passed to \code{\link[lavaan:cfa]{lavaan::cfa()}}.}

\item{type}{Character variable indicating the stage of invariance to be
searched. Currently supported options are (a) for continuous indicators,
"loadings", "intercepts", "residuals", and "residual.covariances", and
(b) "loadings", "thresholds", "residual.covariances", in an increasingly
strict order. A stricter model (e.g., "residual.covariances") will have
constraints of all previous stages.}

\item{test}{Character variable indicating the statistical test to be used
for specification search. Currently supported options are \code{"mod"} for
modification index using \code{lavaan::modindices()} and \code{"score"} for score
test statistic using \code{lavaan::lavTestScore()}.}

\item{sig_level}{Significance level used to determine whether the parameter
associated with the highest modification index should be removed. Default
is .05.}

\item{control_fdr}{Logical; whether to use adjust for false discovery rate
for multiple testing. If \code{TRUE}, the method by Benjamini & Gavrilov (2009)
will be used.}

\item{effect_size}{Logical; whether to compute dmacs (two groups) or
fmacs (> two groups) effect size or not (default).
This is an experimental feature.}

\item{progress}{Logical; an experimental feature of showing a progress bar
if \code{TRUE}. Because the number of steps is unknown until the stopping
criteria are reached, the progress bar may be inaccurate.}
}
\value{
A list of three elements:
\itemize{
\item{\verb{Partial Invariance Fit}}{A \code{\link[lavaan:lavaan-class]{lavaan::lavaan}}
object containing the final partial invariance model.}
\item{\verb{Non-Invariant Items}}{A data frame of non-invariant
parameters.}
\item{\code{effect_size}}{Effect size statistics obtained from
\code{\link[=pin_es]{pin_es()}}.}
}
}
\description{
The function implements the sequential selection method similar to
that discussed in
\href{https://doi.org/10.1080/10705510701301677}{Yoon and Millsap (2007)}.
The function proceeds in the order of metric, scalar (threshold),
and strict invariance. In each stage, invariance constraints in all
items, and the constraint associated with the biggest test
statistic above a predefined threshold is freed, before recomputing
the test statistic for the next constraint to free.
}
\details{
Note that when an item has a non-invariant loading, the
corresponding intercept constraint will automatically be freed,
as intercept difference across groups is sensitive to the location
of the zero point for the latent variable and the item.

For a particular stage of invariance constraints, the Benjamini &
Gavrilov method uses an adjusted \eqn{alpha} level of
\deqn{iq / [m + 1 - i(1 - q)]}
where \eqn{i} is the step index in the search, \eqn{m} is the
maximum number of constraints that can be freed, and \eqn{q} is
the desirable significance level.
}
\examples{
library(lavaan)
library(MASS)
# Simulate random data
set.seed(14)  # for reproducible results
mod_ninv <- "f =~ c(1, 0.8, .6)*y1 + c(0.8, 1.2, 1.0)*y2"
mod_inv <- paste0("1*y", 3:6, collapse = " + ")
sim_mod <- paste(
    paste(mod_ninv, "+", mod_inv),
    "f ~~ c(1, 1.3, 1.5)*f
     f ~ c(0, 0.5, 1.0)*1
     y1 ~ c(0, 0.3, 0)*1
     y3 ~ c(0.3, 0, -0.3)*1
     y1 ~~ c(1, .5, 1)*y1",
    sep = "\n"
)
# The uniqueness of each item is assumed to be 1.0
dat_sim = simulateData(sim_mod, sample.nobs = c(100, 100, 100))
# Fit configural model:
sam_config <- paste(
    paste0('f =~ ', paste0("y", 1:6, collapse = " + "))
)
pinSearch(sam_config, data = dat_sim, group = "group",
          type = "intercepts")
}
\references{
Yoon, M., & Millsap, R. E. (2007). Detecting violations of
factorial invariance using data-based specification searches: A
Monte Carlo study. Structural Equation Modeling: A Multidisciplinary
Journal, 14(3), 435-463.
}
